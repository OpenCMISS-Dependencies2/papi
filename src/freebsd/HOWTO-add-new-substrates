HOW TO ADD SUPPORT IN PAPI FOR NEWER PLATFORMS SUPPORTED IN THE PMC LIBRARY


* Native performance counters vs. PAPI performance counters / derived performance counters
--

There are two different types of performance counters supported in PAPI. Native performance counters are those provided directly by the underlying software (pmc library in FreeBSD, perfmon and perfctr in Linux and pmapi in AIX, among others) and hardware. PAPI performance counters (or derived performance counters) is a set of ideal performance counters that should be representative in most performance analysis. 



* Adding support for the native performance counters from a new CPU
--

Let's review K8Processor_info table from the map-k8.c file as a sample:

  Native_Event_LabelDescription_t K8Processor_info[] =
  {
        { "k8-bu-cpu-clk-unhalted", "Count the number of clock cycles when the CPU is not in the HLT or STPCLCK states" },
        { "k8-bu-fill-request-l2-miss", "Count fill requests that missed in the L2 cache."},
        { "k8-bu-internal-l2-request", "Count internally generated requests to the L2 cache." },
        { "k8-dc-access", "Count data cache accesses including microcode scratchpad accesses."},
...
        { NULL, NULL }
  }


Each entry of this table refers to a single native performance counter as stated in pmc(3). Each entry contains the name to be given to the pmc(3) library and its description (provided by the pmc(3) entry manual). The last entry of this table must be {NULL,NULL}

Once all the native performance counters have been added to the table, create an enumeration for them in the map-k8.h file. The order in this enumeration *MUST* be the same as the defined in the previous table because each entry will represent the position within that table. In addition, the first enumerated value must take the value PAPI_NATIVE_MASK and the latter value should resemble to a GUARD name (as it refers to the pair {NULL,NULL}).

  enum NativeEvent_Value_K8Processor {
        PNE_K8_BU_CPU_CLK_UNHALTED = PAPI_NATIVE_MASK,
        PNE_K8_BU_FILL_REQUEST_L2_MISS,
        PNE_K8_BU_INTERNAL_L2_REQUEST,
        PNE_K8_DC_ACCESS,
...
        PNE_K8_NATNAME_GUARD
  }

  The name scheme I chose is: PNE (for PAPI native event) followed by the name of the performance counter in uppercase. So PNE_K8_BU_CPU_CLK_UNHALTED refers to the PAPI native event k8-bu-cpu-clk-unhalted.



* Adding support for the PAPI performance counters
--

There are more than a hundred PAPI performance counters. Use the program papi_avail distributed with the PAPI program to get information about them or check the any-null.c file, table preset_map to get a default table for PAPI performance counters.

PAPI performance counters are built on top of the native performance counters. Sometimes, some PAPI performance counters are mapped directly into native events. Others are built  using several performance counters and operating with them. Finally, some cannot be provided by the unavailability of resources (or native performance counters). Such translation is done with a conversion table.

Again in the map-k8.c file, taking a look to K8Processor_map table we see:

        {PAPI_BR_INS, {0, {PNE_K8_FR_RETIRED_BRANCHES, PAPI_NULL}, {0,}}},

Which means:

   PAPI_BR_INS (branch instructions) is mapped directly to PNE_K8_FR_RETIRED_BRANCHES.

It is important to place the PAPI_NULL terminator so as PAPI understands that there is just one native performance counter mapped for that PAPI counter.

However, the entry:

        {PAPI_L1_TCA, {DERIVED_ADD, {PNE_K8_DC_ACCESS, PNE_K8_IC_FETCH, PAPI_NULL}, {0,}}},

means

   PAPI_L1_TCA (level 1 total cache accesses) is the sum of the PNE_K8_DC_ACCESS and PNE_K8_IC_FETCH.

   It is important to check whether the compiling substrate (i.e., the running substrate) can affort using as many PMCs as defined. For example, on the former example the user must check that the processor can use at least 2 PMCs at the same time. There is a define (HWPMC_NUM_COUNTERS) that is defined at ./configure time and contains the number of performance counters that can be used at the same time. The previous example should be written as

      #if HWPMC_NUM_COUNTERS >= 2
        {PAPI_L1_TCA, {DERIVED_ADD, {PNE_K8_DC_ACCESS, PNE_K8_IC_FETCH, PAPI_NULL}, {0,}}},
      #endif

See papi_internal.h for other available operations.



* Special cases
--

  Some PAPI counters require that the native counters use "extra flags" from the counter to count on specific circumstances. To manage them, I've just placed the counter plus its flags as a new separate counter. Again, in map-k8.c we can find the native counter

  { "k8-dc-refill-from-l2,mask=+modified,+owner,+exclusive,+shared", "Count data cache refills from L2 cache (in MOES state)." },

  Which is the same k8-dc-refill-from-l2 but only on the MOES state. Its enumeration gets the name PNE_K8_DC_REFILL_FROM_L2_MOES.

  This is depends heavily on the semantic of the PAPI counter and the available native counters (and flags).



* Last things to do
--

Add support for the new tables:

  1.- Add to freebsd/map.h a new enumerated value for the new CPU type in the unnamed enumeration found on top of the file. Also #include the new header file.
  2.- Add to freebsd/map.c the new tables (info and map) in the previously new CPU enumerated value in the init_freebsd_libpmc_mappings routine.
  3.- Add to freebsd.c the appropriate CPU identification check in the init_presets routine and se the appropriate Context.CPUsubstrate to the new CPU enumerated value.

Once the new mapping tables and the enumeration are done and included in the freebsd/map.[ch] files, the Makefile.freebsd must be taught to build them. Just add a new entry for the new mapping file like others exist in the Makefile.freebsd (Makefile order to build the C file and an entry in MISCHDRS and MISCSRCS variables).



* Testing it
--

In order to test both if those tables are well constructed just try the binaries: papi_decode, papi_avail and papi_native_avail distributed with PAPI. The first program will show how the derived performance counters are built. The two latter will show the availability of the derived and native performance counters respectively.

